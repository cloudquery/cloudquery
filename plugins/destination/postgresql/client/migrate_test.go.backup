package client

import (
	"context"
	"net"
	"testing"
	"time"

	"github.com/cloudquery/plugin-sdk/schema"
	"github.com/cloudquery/plugin-sdk/specs"
	uuid "github.com/vgarvardt/pgx-google-uuid/v4"
)
type testRow struct {
	CqId uuid.UUID
	CqParentId uuid.UUID
	CqSourceName string
	CqSyncTime time.Time
	Id uuid.UUID
	Bool bool
	Int int
	Float float64
	Uuid uuid.UUID
	String string
	StringArray []string 
	IntArray []int
	Timestamp time.Time
	Interval time.Duration
	Json map[string]interface{}
	UuidArray []*uuid.UUID
	Inet net.IP
	InetArray []net.IP
	Cidr net.IPNet
	CidrArray []net.IPNet
	Mac string
}

func TestMigrate(t *testing.T) {
	ctx := context.Background()
	client, err := New(ctx, getTestLogger(t), specs.Destination{
		WriteMode: specs.WriteModeOverwriteDeleteStale,
		Spec: &Spec{
			PgxLogLevel:      LogLevelDebug,
			ConnectionString: getTestConnection(),
			BatchSize:        1,
		},
	})
	if err != nil {
		t.Fatalf("failed to initialize client: %v", err)
	}
	c := client.(*Client)
	tables := []*schema.Table{
		{
			Name: "test_table",
			Columns: schema.ColumnList{
				schema.CqIDColumn,
				{
					Name: "test_column",
					Type: schema.TypeString,
				},
			},
		},
	}
	table := tables[0]
	testData := getTestData()

	// check migration logic
	if err := c.Drop(ctx, tables); err != nil {
		t.Fatalf("failed to drop tables: %v", err)
	}
	if err := c.Migrate(ctx, tables); err != nil {
		t.Fatalf("failed to migrate tables: %v", err)
	}
	isExist, err := c.isTableExistSQL(ctx, table.Name)
	if err != nil {
		t.Fatalf("failed to check if table exists: %v", err)
	}
	if !isExist {
		t.Fatalf("failed to migrate table. table %s doesn't exist", table.Name)
	}
	// test that calling migrate twice works
	if err := c.Migrate(ctx, tables); err != nil {
		t.Fatalf("failed to migrate tables second time: %v", err)
	}

	// check migration without column does nothing
	table.Columns = table.Columns[:len(table.Columns)-1]
	if err := c.Migrate(ctx, []*schema.Table{table}); err != nil {
		t.Fatalf("failed to migrate tables with missing column: %v", err)
	}

	// migrate primary key
	testTable.Columns[2].CreationOptions.PrimaryKey = true
	if err := c.Migrate(ctx, []*schema.Table{testTable}); err != nil {
		t.Fatalf("failed to migrate tables with missing column: %v", err)
	}
	testTables = schema.Tables{getTestTable()}
	resources := make(chan *schema.DestinationResource, 1)
	resources <- testData
	close(resources)
	if err := c.Write(ctx, testTables, resources); err != nil {
		t.Fatalf("failed to write data: %v", err)
	}
	
}
