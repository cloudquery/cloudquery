// Code generated by MockGen. DO NOT EDIT.
// Source: glue.go

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	glue "github.com/aws/aws-sdk-go-v2/service/glue"
	gomock "github.com/golang/mock/gomock"
)

// MockGlueClient is a mock of GlueClient interface.
type MockGlueClient struct {
	ctrl     *gomock.Controller
	recorder *MockGlueClientMockRecorder
}

// MockGlueClientMockRecorder is the mock recorder for MockGlueClient.
type MockGlueClientMockRecorder struct {
	mock *MockGlueClient
}

// NewMockGlueClient creates a new mock instance.
func NewMockGlueClient(ctrl *gomock.Controller) *MockGlueClient {
	mock := &MockGlueClient{ctrl: ctrl}
	mock.recorder = &MockGlueClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGlueClient) EXPECT() *MockGlueClientMockRecorder {
	return m.recorder
}

// BatchGetBlueprints mocks base method.
func (m *MockGlueClient) BatchGetBlueprints(arg0 context.Context, arg1 *glue.BatchGetBlueprintsInput, arg2 ...func(*glue.Options)) (*glue.BatchGetBlueprintsOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to BatchGetBlueprints")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchGetBlueprints", varargs...)
	ret0, _ := ret[0].(*glue.BatchGetBlueprintsOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BatchGetBlueprints indicates an expected call of BatchGetBlueprints.
func (mr *MockGlueClientMockRecorder) BatchGetBlueprints(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchGetBlueprints", reflect.TypeOf((*MockGlueClient)(nil).BatchGetBlueprints), varargs...)
}

// BatchGetCrawlers mocks base method.
func (m *MockGlueClient) BatchGetCrawlers(arg0 context.Context, arg1 *glue.BatchGetCrawlersInput, arg2 ...func(*glue.Options)) (*glue.BatchGetCrawlersOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to BatchGetCrawlers")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchGetCrawlers", varargs...)
	ret0, _ := ret[0].(*glue.BatchGetCrawlersOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BatchGetCrawlers indicates an expected call of BatchGetCrawlers.
func (mr *MockGlueClientMockRecorder) BatchGetCrawlers(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchGetCrawlers", reflect.TypeOf((*MockGlueClient)(nil).BatchGetCrawlers), varargs...)
}

// BatchGetCustomEntityTypes mocks base method.
func (m *MockGlueClient) BatchGetCustomEntityTypes(arg0 context.Context, arg1 *glue.BatchGetCustomEntityTypesInput, arg2 ...func(*glue.Options)) (*glue.BatchGetCustomEntityTypesOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to BatchGetCustomEntityTypes")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchGetCustomEntityTypes", varargs...)
	ret0, _ := ret[0].(*glue.BatchGetCustomEntityTypesOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BatchGetCustomEntityTypes indicates an expected call of BatchGetCustomEntityTypes.
func (mr *MockGlueClientMockRecorder) BatchGetCustomEntityTypes(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchGetCustomEntityTypes", reflect.TypeOf((*MockGlueClient)(nil).BatchGetCustomEntityTypes), varargs...)
}

// BatchGetDataQualityResult mocks base method.
func (m *MockGlueClient) BatchGetDataQualityResult(arg0 context.Context, arg1 *glue.BatchGetDataQualityResultInput, arg2 ...func(*glue.Options)) (*glue.BatchGetDataQualityResultOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to BatchGetDataQualityResult")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchGetDataQualityResult", varargs...)
	ret0, _ := ret[0].(*glue.BatchGetDataQualityResultOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BatchGetDataQualityResult indicates an expected call of BatchGetDataQualityResult.
func (mr *MockGlueClientMockRecorder) BatchGetDataQualityResult(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchGetDataQualityResult", reflect.TypeOf((*MockGlueClient)(nil).BatchGetDataQualityResult), varargs...)
}

// BatchGetDevEndpoints mocks base method.
func (m *MockGlueClient) BatchGetDevEndpoints(arg0 context.Context, arg1 *glue.BatchGetDevEndpointsInput, arg2 ...func(*glue.Options)) (*glue.BatchGetDevEndpointsOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to BatchGetDevEndpoints")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchGetDevEndpoints", varargs...)
	ret0, _ := ret[0].(*glue.BatchGetDevEndpointsOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BatchGetDevEndpoints indicates an expected call of BatchGetDevEndpoints.
func (mr *MockGlueClientMockRecorder) BatchGetDevEndpoints(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchGetDevEndpoints", reflect.TypeOf((*MockGlueClient)(nil).BatchGetDevEndpoints), varargs...)
}

// BatchGetJobs mocks base method.
func (m *MockGlueClient) BatchGetJobs(arg0 context.Context, arg1 *glue.BatchGetJobsInput, arg2 ...func(*glue.Options)) (*glue.BatchGetJobsOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to BatchGetJobs")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchGetJobs", varargs...)
	ret0, _ := ret[0].(*glue.BatchGetJobsOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BatchGetJobs indicates an expected call of BatchGetJobs.
func (mr *MockGlueClientMockRecorder) BatchGetJobs(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchGetJobs", reflect.TypeOf((*MockGlueClient)(nil).BatchGetJobs), varargs...)
}

// BatchGetPartition mocks base method.
func (m *MockGlueClient) BatchGetPartition(arg0 context.Context, arg1 *glue.BatchGetPartitionInput, arg2 ...func(*glue.Options)) (*glue.BatchGetPartitionOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to BatchGetPartition")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchGetPartition", varargs...)
	ret0, _ := ret[0].(*glue.BatchGetPartitionOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BatchGetPartition indicates an expected call of BatchGetPartition.
func (mr *MockGlueClientMockRecorder) BatchGetPartition(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchGetPartition", reflect.TypeOf((*MockGlueClient)(nil).BatchGetPartition), varargs...)
}

// BatchGetTriggers mocks base method.
func (m *MockGlueClient) BatchGetTriggers(arg0 context.Context, arg1 *glue.BatchGetTriggersInput, arg2 ...func(*glue.Options)) (*glue.BatchGetTriggersOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to BatchGetTriggers")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchGetTriggers", varargs...)
	ret0, _ := ret[0].(*glue.BatchGetTriggersOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BatchGetTriggers indicates an expected call of BatchGetTriggers.
func (mr *MockGlueClientMockRecorder) BatchGetTriggers(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchGetTriggers", reflect.TypeOf((*MockGlueClient)(nil).BatchGetTriggers), varargs...)
}

// BatchGetWorkflows mocks base method.
func (m *MockGlueClient) BatchGetWorkflows(arg0 context.Context, arg1 *glue.BatchGetWorkflowsInput, arg2 ...func(*glue.Options)) (*glue.BatchGetWorkflowsOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to BatchGetWorkflows")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchGetWorkflows", varargs...)
	ret0, _ := ret[0].(*glue.BatchGetWorkflowsOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BatchGetWorkflows indicates an expected call of BatchGetWorkflows.
func (mr *MockGlueClientMockRecorder) BatchGetWorkflows(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchGetWorkflows", reflect.TypeOf((*MockGlueClient)(nil).BatchGetWorkflows), varargs...)
}

// GetBlueprint mocks base method.
func (m *MockGlueClient) GetBlueprint(arg0 context.Context, arg1 *glue.GetBlueprintInput, arg2 ...func(*glue.Options)) (*glue.GetBlueprintOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetBlueprint")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetBlueprint", varargs...)
	ret0, _ := ret[0].(*glue.GetBlueprintOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBlueprint indicates an expected call of GetBlueprint.
func (mr *MockGlueClientMockRecorder) GetBlueprint(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBlueprint", reflect.TypeOf((*MockGlueClient)(nil).GetBlueprint), varargs...)
}

// GetBlueprintRun mocks base method.
func (m *MockGlueClient) GetBlueprintRun(arg0 context.Context, arg1 *glue.GetBlueprintRunInput, arg2 ...func(*glue.Options)) (*glue.GetBlueprintRunOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetBlueprintRun")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetBlueprintRun", varargs...)
	ret0, _ := ret[0].(*glue.GetBlueprintRunOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBlueprintRun indicates an expected call of GetBlueprintRun.
func (mr *MockGlueClientMockRecorder) GetBlueprintRun(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBlueprintRun", reflect.TypeOf((*MockGlueClient)(nil).GetBlueprintRun), varargs...)
}

// GetBlueprintRuns mocks base method.
func (m *MockGlueClient) GetBlueprintRuns(arg0 context.Context, arg1 *glue.GetBlueprintRunsInput, arg2 ...func(*glue.Options)) (*glue.GetBlueprintRunsOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetBlueprintRuns")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetBlueprintRuns", varargs...)
	ret0, _ := ret[0].(*glue.GetBlueprintRunsOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBlueprintRuns indicates an expected call of GetBlueprintRuns.
func (mr *MockGlueClientMockRecorder) GetBlueprintRuns(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBlueprintRuns", reflect.TypeOf((*MockGlueClient)(nil).GetBlueprintRuns), varargs...)
}

// GetCatalogImportStatus mocks base method.
func (m *MockGlueClient) GetCatalogImportStatus(arg0 context.Context, arg1 *glue.GetCatalogImportStatusInput, arg2 ...func(*glue.Options)) (*glue.GetCatalogImportStatusOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetCatalogImportStatus")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetCatalogImportStatus", varargs...)
	ret0, _ := ret[0].(*glue.GetCatalogImportStatusOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCatalogImportStatus indicates an expected call of GetCatalogImportStatus.
func (mr *MockGlueClientMockRecorder) GetCatalogImportStatus(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCatalogImportStatus", reflect.TypeOf((*MockGlueClient)(nil).GetCatalogImportStatus), varargs...)
}

// GetClassifier mocks base method.
func (m *MockGlueClient) GetClassifier(arg0 context.Context, arg1 *glue.GetClassifierInput, arg2 ...func(*glue.Options)) (*glue.GetClassifierOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetClassifier")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetClassifier", varargs...)
	ret0, _ := ret[0].(*glue.GetClassifierOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetClassifier indicates an expected call of GetClassifier.
func (mr *MockGlueClientMockRecorder) GetClassifier(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetClassifier", reflect.TypeOf((*MockGlueClient)(nil).GetClassifier), varargs...)
}

// GetClassifiers mocks base method.
func (m *MockGlueClient) GetClassifiers(arg0 context.Context, arg1 *glue.GetClassifiersInput, arg2 ...func(*glue.Options)) (*glue.GetClassifiersOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetClassifiers")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetClassifiers", varargs...)
	ret0, _ := ret[0].(*glue.GetClassifiersOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetClassifiers indicates an expected call of GetClassifiers.
func (mr *MockGlueClientMockRecorder) GetClassifiers(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetClassifiers", reflect.TypeOf((*MockGlueClient)(nil).GetClassifiers), varargs...)
}

// GetColumnStatisticsForPartition mocks base method.
func (m *MockGlueClient) GetColumnStatisticsForPartition(arg0 context.Context, arg1 *glue.GetColumnStatisticsForPartitionInput, arg2 ...func(*glue.Options)) (*glue.GetColumnStatisticsForPartitionOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetColumnStatisticsForPartition")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetColumnStatisticsForPartition", varargs...)
	ret0, _ := ret[0].(*glue.GetColumnStatisticsForPartitionOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetColumnStatisticsForPartition indicates an expected call of GetColumnStatisticsForPartition.
func (mr *MockGlueClientMockRecorder) GetColumnStatisticsForPartition(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetColumnStatisticsForPartition", reflect.TypeOf((*MockGlueClient)(nil).GetColumnStatisticsForPartition), varargs...)
}

// GetColumnStatisticsForTable mocks base method.
func (m *MockGlueClient) GetColumnStatisticsForTable(arg0 context.Context, arg1 *glue.GetColumnStatisticsForTableInput, arg2 ...func(*glue.Options)) (*glue.GetColumnStatisticsForTableOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetColumnStatisticsForTable")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetColumnStatisticsForTable", varargs...)
	ret0, _ := ret[0].(*glue.GetColumnStatisticsForTableOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetColumnStatisticsForTable indicates an expected call of GetColumnStatisticsForTable.
func (mr *MockGlueClientMockRecorder) GetColumnStatisticsForTable(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetColumnStatisticsForTable", reflect.TypeOf((*MockGlueClient)(nil).GetColumnStatisticsForTable), varargs...)
}

// GetConnection mocks base method.
func (m *MockGlueClient) GetConnection(arg0 context.Context, arg1 *glue.GetConnectionInput, arg2 ...func(*glue.Options)) (*glue.GetConnectionOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetConnection")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetConnection", varargs...)
	ret0, _ := ret[0].(*glue.GetConnectionOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetConnection indicates an expected call of GetConnection.
func (mr *MockGlueClientMockRecorder) GetConnection(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetConnection", reflect.TypeOf((*MockGlueClient)(nil).GetConnection), varargs...)
}

// GetConnections mocks base method.
func (m *MockGlueClient) GetConnections(arg0 context.Context, arg1 *glue.GetConnectionsInput, arg2 ...func(*glue.Options)) (*glue.GetConnectionsOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetConnections")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetConnections", varargs...)
	ret0, _ := ret[0].(*glue.GetConnectionsOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetConnections indicates an expected call of GetConnections.
func (mr *MockGlueClientMockRecorder) GetConnections(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetConnections", reflect.TypeOf((*MockGlueClient)(nil).GetConnections), varargs...)
}

// GetCrawler mocks base method.
func (m *MockGlueClient) GetCrawler(arg0 context.Context, arg1 *glue.GetCrawlerInput, arg2 ...func(*glue.Options)) (*glue.GetCrawlerOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetCrawler")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetCrawler", varargs...)
	ret0, _ := ret[0].(*glue.GetCrawlerOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCrawler indicates an expected call of GetCrawler.
func (mr *MockGlueClientMockRecorder) GetCrawler(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCrawler", reflect.TypeOf((*MockGlueClient)(nil).GetCrawler), varargs...)
}

// GetCrawlerMetrics mocks base method.
func (m *MockGlueClient) GetCrawlerMetrics(arg0 context.Context, arg1 *glue.GetCrawlerMetricsInput, arg2 ...func(*glue.Options)) (*glue.GetCrawlerMetricsOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetCrawlerMetrics")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetCrawlerMetrics", varargs...)
	ret0, _ := ret[0].(*glue.GetCrawlerMetricsOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCrawlerMetrics indicates an expected call of GetCrawlerMetrics.
func (mr *MockGlueClientMockRecorder) GetCrawlerMetrics(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCrawlerMetrics", reflect.TypeOf((*MockGlueClient)(nil).GetCrawlerMetrics), varargs...)
}

// GetCrawlers mocks base method.
func (m *MockGlueClient) GetCrawlers(arg0 context.Context, arg1 *glue.GetCrawlersInput, arg2 ...func(*glue.Options)) (*glue.GetCrawlersOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetCrawlers")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetCrawlers", varargs...)
	ret0, _ := ret[0].(*glue.GetCrawlersOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCrawlers indicates an expected call of GetCrawlers.
func (mr *MockGlueClientMockRecorder) GetCrawlers(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCrawlers", reflect.TypeOf((*MockGlueClient)(nil).GetCrawlers), varargs...)
}

// GetCustomEntityType mocks base method.
func (m *MockGlueClient) GetCustomEntityType(arg0 context.Context, arg1 *glue.GetCustomEntityTypeInput, arg2 ...func(*glue.Options)) (*glue.GetCustomEntityTypeOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetCustomEntityType")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetCustomEntityType", varargs...)
	ret0, _ := ret[0].(*glue.GetCustomEntityTypeOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCustomEntityType indicates an expected call of GetCustomEntityType.
func (mr *MockGlueClientMockRecorder) GetCustomEntityType(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCustomEntityType", reflect.TypeOf((*MockGlueClient)(nil).GetCustomEntityType), varargs...)
}

// GetDataCatalogEncryptionSettings mocks base method.
func (m *MockGlueClient) GetDataCatalogEncryptionSettings(arg0 context.Context, arg1 *glue.GetDataCatalogEncryptionSettingsInput, arg2 ...func(*glue.Options)) (*glue.GetDataCatalogEncryptionSettingsOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetDataCatalogEncryptionSettings")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetDataCatalogEncryptionSettings", varargs...)
	ret0, _ := ret[0].(*glue.GetDataCatalogEncryptionSettingsOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetDataCatalogEncryptionSettings indicates an expected call of GetDataCatalogEncryptionSettings.
func (mr *MockGlueClientMockRecorder) GetDataCatalogEncryptionSettings(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetDataCatalogEncryptionSettings", reflect.TypeOf((*MockGlueClient)(nil).GetDataCatalogEncryptionSettings), varargs...)
}

// GetDataQualityResult mocks base method.
func (m *MockGlueClient) GetDataQualityResult(arg0 context.Context, arg1 *glue.GetDataQualityResultInput, arg2 ...func(*glue.Options)) (*glue.GetDataQualityResultOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetDataQualityResult")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetDataQualityResult", varargs...)
	ret0, _ := ret[0].(*glue.GetDataQualityResultOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetDataQualityResult indicates an expected call of GetDataQualityResult.
func (mr *MockGlueClientMockRecorder) GetDataQualityResult(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetDataQualityResult", reflect.TypeOf((*MockGlueClient)(nil).GetDataQualityResult), varargs...)
}

// GetDataQualityRuleRecommendationRun mocks base method.
func (m *MockGlueClient) GetDataQualityRuleRecommendationRun(arg0 context.Context, arg1 *glue.GetDataQualityRuleRecommendationRunInput, arg2 ...func(*glue.Options)) (*glue.GetDataQualityRuleRecommendationRunOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetDataQualityRuleRecommendationRun")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetDataQualityRuleRecommendationRun", varargs...)
	ret0, _ := ret[0].(*glue.GetDataQualityRuleRecommendationRunOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetDataQualityRuleRecommendationRun indicates an expected call of GetDataQualityRuleRecommendationRun.
func (mr *MockGlueClientMockRecorder) GetDataQualityRuleRecommendationRun(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetDataQualityRuleRecommendationRun", reflect.TypeOf((*MockGlueClient)(nil).GetDataQualityRuleRecommendationRun), varargs...)
}

// GetDataQualityRuleset mocks base method.
func (m *MockGlueClient) GetDataQualityRuleset(arg0 context.Context, arg1 *glue.GetDataQualityRulesetInput, arg2 ...func(*glue.Options)) (*glue.GetDataQualityRulesetOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetDataQualityRuleset")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetDataQualityRuleset", varargs...)
	ret0, _ := ret[0].(*glue.GetDataQualityRulesetOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetDataQualityRuleset indicates an expected call of GetDataQualityRuleset.
func (mr *MockGlueClientMockRecorder) GetDataQualityRuleset(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetDataQualityRuleset", reflect.TypeOf((*MockGlueClient)(nil).GetDataQualityRuleset), varargs...)
}

// GetDataQualityRulesetEvaluationRun mocks base method.
func (m *MockGlueClient) GetDataQualityRulesetEvaluationRun(arg0 context.Context, arg1 *glue.GetDataQualityRulesetEvaluationRunInput, arg2 ...func(*glue.Options)) (*glue.GetDataQualityRulesetEvaluationRunOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetDataQualityRulesetEvaluationRun")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetDataQualityRulesetEvaluationRun", varargs...)
	ret0, _ := ret[0].(*glue.GetDataQualityRulesetEvaluationRunOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetDataQualityRulesetEvaluationRun indicates an expected call of GetDataQualityRulesetEvaluationRun.
func (mr *MockGlueClientMockRecorder) GetDataQualityRulesetEvaluationRun(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetDataQualityRulesetEvaluationRun", reflect.TypeOf((*MockGlueClient)(nil).GetDataQualityRulesetEvaluationRun), varargs...)
}

// GetDatabase mocks base method.
func (m *MockGlueClient) GetDatabase(arg0 context.Context, arg1 *glue.GetDatabaseInput, arg2 ...func(*glue.Options)) (*glue.GetDatabaseOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetDatabase")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetDatabase", varargs...)
	ret0, _ := ret[0].(*glue.GetDatabaseOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetDatabase indicates an expected call of GetDatabase.
func (mr *MockGlueClientMockRecorder) GetDatabase(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetDatabase", reflect.TypeOf((*MockGlueClient)(nil).GetDatabase), varargs...)
}

// GetDatabases mocks base method.
func (m *MockGlueClient) GetDatabases(arg0 context.Context, arg1 *glue.GetDatabasesInput, arg2 ...func(*glue.Options)) (*glue.GetDatabasesOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetDatabases")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetDatabases", varargs...)
	ret0, _ := ret[0].(*glue.GetDatabasesOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetDatabases indicates an expected call of GetDatabases.
func (mr *MockGlueClientMockRecorder) GetDatabases(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetDatabases", reflect.TypeOf((*MockGlueClient)(nil).GetDatabases), varargs...)
}

// GetDataflowGraph mocks base method.
func (m *MockGlueClient) GetDataflowGraph(arg0 context.Context, arg1 *glue.GetDataflowGraphInput, arg2 ...func(*glue.Options)) (*glue.GetDataflowGraphOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetDataflowGraph")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetDataflowGraph", varargs...)
	ret0, _ := ret[0].(*glue.GetDataflowGraphOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetDataflowGraph indicates an expected call of GetDataflowGraph.
func (mr *MockGlueClientMockRecorder) GetDataflowGraph(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetDataflowGraph", reflect.TypeOf((*MockGlueClient)(nil).GetDataflowGraph), varargs...)
}

// GetDevEndpoint mocks base method.
func (m *MockGlueClient) GetDevEndpoint(arg0 context.Context, arg1 *glue.GetDevEndpointInput, arg2 ...func(*glue.Options)) (*glue.GetDevEndpointOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetDevEndpoint")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetDevEndpoint", varargs...)
	ret0, _ := ret[0].(*glue.GetDevEndpointOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetDevEndpoint indicates an expected call of GetDevEndpoint.
func (mr *MockGlueClientMockRecorder) GetDevEndpoint(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetDevEndpoint", reflect.TypeOf((*MockGlueClient)(nil).GetDevEndpoint), varargs...)
}

// GetDevEndpoints mocks base method.
func (m *MockGlueClient) GetDevEndpoints(arg0 context.Context, arg1 *glue.GetDevEndpointsInput, arg2 ...func(*glue.Options)) (*glue.GetDevEndpointsOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetDevEndpoints")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetDevEndpoints", varargs...)
	ret0, _ := ret[0].(*glue.GetDevEndpointsOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetDevEndpoints indicates an expected call of GetDevEndpoints.
func (mr *MockGlueClientMockRecorder) GetDevEndpoints(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetDevEndpoints", reflect.TypeOf((*MockGlueClient)(nil).GetDevEndpoints), varargs...)
}

// GetJob mocks base method.
func (m *MockGlueClient) GetJob(arg0 context.Context, arg1 *glue.GetJobInput, arg2 ...func(*glue.Options)) (*glue.GetJobOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetJob")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetJob", varargs...)
	ret0, _ := ret[0].(*glue.GetJobOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetJob indicates an expected call of GetJob.
func (mr *MockGlueClientMockRecorder) GetJob(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetJob", reflect.TypeOf((*MockGlueClient)(nil).GetJob), varargs...)
}

// GetJobBookmark mocks base method.
func (m *MockGlueClient) GetJobBookmark(arg0 context.Context, arg1 *glue.GetJobBookmarkInput, arg2 ...func(*glue.Options)) (*glue.GetJobBookmarkOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetJobBookmark")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetJobBookmark", varargs...)
	ret0, _ := ret[0].(*glue.GetJobBookmarkOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetJobBookmark indicates an expected call of GetJobBookmark.
func (mr *MockGlueClientMockRecorder) GetJobBookmark(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetJobBookmark", reflect.TypeOf((*MockGlueClient)(nil).GetJobBookmark), varargs...)
}

// GetJobRun mocks base method.
func (m *MockGlueClient) GetJobRun(arg0 context.Context, arg1 *glue.GetJobRunInput, arg2 ...func(*glue.Options)) (*glue.GetJobRunOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetJobRun")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetJobRun", varargs...)
	ret0, _ := ret[0].(*glue.GetJobRunOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetJobRun indicates an expected call of GetJobRun.
func (mr *MockGlueClientMockRecorder) GetJobRun(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetJobRun", reflect.TypeOf((*MockGlueClient)(nil).GetJobRun), varargs...)
}

// GetJobRuns mocks base method.
func (m *MockGlueClient) GetJobRuns(arg0 context.Context, arg1 *glue.GetJobRunsInput, arg2 ...func(*glue.Options)) (*glue.GetJobRunsOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetJobRuns")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetJobRuns", varargs...)
	ret0, _ := ret[0].(*glue.GetJobRunsOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetJobRuns indicates an expected call of GetJobRuns.
func (mr *MockGlueClientMockRecorder) GetJobRuns(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetJobRuns", reflect.TypeOf((*MockGlueClient)(nil).GetJobRuns), varargs...)
}

// GetJobs mocks base method.
func (m *MockGlueClient) GetJobs(arg0 context.Context, arg1 *glue.GetJobsInput, arg2 ...func(*glue.Options)) (*glue.GetJobsOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetJobs")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetJobs", varargs...)
	ret0, _ := ret[0].(*glue.GetJobsOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetJobs indicates an expected call of GetJobs.
func (mr *MockGlueClientMockRecorder) GetJobs(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetJobs", reflect.TypeOf((*MockGlueClient)(nil).GetJobs), varargs...)
}

// GetMLTaskRun mocks base method.
func (m *MockGlueClient) GetMLTaskRun(arg0 context.Context, arg1 *glue.GetMLTaskRunInput, arg2 ...func(*glue.Options)) (*glue.GetMLTaskRunOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetMLTaskRun")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetMLTaskRun", varargs...)
	ret0, _ := ret[0].(*glue.GetMLTaskRunOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetMLTaskRun indicates an expected call of GetMLTaskRun.
func (mr *MockGlueClientMockRecorder) GetMLTaskRun(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMLTaskRun", reflect.TypeOf((*MockGlueClient)(nil).GetMLTaskRun), varargs...)
}

// GetMLTaskRuns mocks base method.
func (m *MockGlueClient) GetMLTaskRuns(arg0 context.Context, arg1 *glue.GetMLTaskRunsInput, arg2 ...func(*glue.Options)) (*glue.GetMLTaskRunsOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetMLTaskRuns")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetMLTaskRuns", varargs...)
	ret0, _ := ret[0].(*glue.GetMLTaskRunsOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetMLTaskRuns indicates an expected call of GetMLTaskRuns.
func (mr *MockGlueClientMockRecorder) GetMLTaskRuns(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMLTaskRuns", reflect.TypeOf((*MockGlueClient)(nil).GetMLTaskRuns), varargs...)
}

// GetMLTransform mocks base method.
func (m *MockGlueClient) GetMLTransform(arg0 context.Context, arg1 *glue.GetMLTransformInput, arg2 ...func(*glue.Options)) (*glue.GetMLTransformOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetMLTransform")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetMLTransform", varargs...)
	ret0, _ := ret[0].(*glue.GetMLTransformOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetMLTransform indicates an expected call of GetMLTransform.
func (mr *MockGlueClientMockRecorder) GetMLTransform(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMLTransform", reflect.TypeOf((*MockGlueClient)(nil).GetMLTransform), varargs...)
}

// GetMLTransforms mocks base method.
func (m *MockGlueClient) GetMLTransforms(arg0 context.Context, arg1 *glue.GetMLTransformsInput, arg2 ...func(*glue.Options)) (*glue.GetMLTransformsOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetMLTransforms")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetMLTransforms", varargs...)
	ret0, _ := ret[0].(*glue.GetMLTransformsOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetMLTransforms indicates an expected call of GetMLTransforms.
func (mr *MockGlueClientMockRecorder) GetMLTransforms(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMLTransforms", reflect.TypeOf((*MockGlueClient)(nil).GetMLTransforms), varargs...)
}

// GetMapping mocks base method.
func (m *MockGlueClient) GetMapping(arg0 context.Context, arg1 *glue.GetMappingInput, arg2 ...func(*glue.Options)) (*glue.GetMappingOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetMapping")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetMapping", varargs...)
	ret0, _ := ret[0].(*glue.GetMappingOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetMapping indicates an expected call of GetMapping.
func (mr *MockGlueClientMockRecorder) GetMapping(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMapping", reflect.TypeOf((*MockGlueClient)(nil).GetMapping), varargs...)
}

// GetPartition mocks base method.
func (m *MockGlueClient) GetPartition(arg0 context.Context, arg1 *glue.GetPartitionInput, arg2 ...func(*glue.Options)) (*glue.GetPartitionOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetPartition")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetPartition", varargs...)
	ret0, _ := ret[0].(*glue.GetPartitionOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetPartition indicates an expected call of GetPartition.
func (mr *MockGlueClientMockRecorder) GetPartition(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPartition", reflect.TypeOf((*MockGlueClient)(nil).GetPartition), varargs...)
}

// GetPartitionIndexes mocks base method.
func (m *MockGlueClient) GetPartitionIndexes(arg0 context.Context, arg1 *glue.GetPartitionIndexesInput, arg2 ...func(*glue.Options)) (*glue.GetPartitionIndexesOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetPartitionIndexes")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetPartitionIndexes", varargs...)
	ret0, _ := ret[0].(*glue.GetPartitionIndexesOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetPartitionIndexes indicates an expected call of GetPartitionIndexes.
func (mr *MockGlueClientMockRecorder) GetPartitionIndexes(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPartitionIndexes", reflect.TypeOf((*MockGlueClient)(nil).GetPartitionIndexes), varargs...)
}

// GetPartitions mocks base method.
func (m *MockGlueClient) GetPartitions(arg0 context.Context, arg1 *glue.GetPartitionsInput, arg2 ...func(*glue.Options)) (*glue.GetPartitionsOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetPartitions")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetPartitions", varargs...)
	ret0, _ := ret[0].(*glue.GetPartitionsOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetPartitions indicates an expected call of GetPartitions.
func (mr *MockGlueClientMockRecorder) GetPartitions(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPartitions", reflect.TypeOf((*MockGlueClient)(nil).GetPartitions), varargs...)
}

// GetPlan mocks base method.
func (m *MockGlueClient) GetPlan(arg0 context.Context, arg1 *glue.GetPlanInput, arg2 ...func(*glue.Options)) (*glue.GetPlanOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetPlan")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetPlan", varargs...)
	ret0, _ := ret[0].(*glue.GetPlanOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetPlan indicates an expected call of GetPlan.
func (mr *MockGlueClientMockRecorder) GetPlan(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPlan", reflect.TypeOf((*MockGlueClient)(nil).GetPlan), varargs...)
}

// GetRegistry mocks base method.
func (m *MockGlueClient) GetRegistry(arg0 context.Context, arg1 *glue.GetRegistryInput, arg2 ...func(*glue.Options)) (*glue.GetRegistryOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetRegistry")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetRegistry", varargs...)
	ret0, _ := ret[0].(*glue.GetRegistryOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetRegistry indicates an expected call of GetRegistry.
func (mr *MockGlueClientMockRecorder) GetRegistry(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRegistry", reflect.TypeOf((*MockGlueClient)(nil).GetRegistry), varargs...)
}

// GetResourcePolicies mocks base method.
func (m *MockGlueClient) GetResourcePolicies(arg0 context.Context, arg1 *glue.GetResourcePoliciesInput, arg2 ...func(*glue.Options)) (*glue.GetResourcePoliciesOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetResourcePolicies")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetResourcePolicies", varargs...)
	ret0, _ := ret[0].(*glue.GetResourcePoliciesOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetResourcePolicies indicates an expected call of GetResourcePolicies.
func (mr *MockGlueClientMockRecorder) GetResourcePolicies(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetResourcePolicies", reflect.TypeOf((*MockGlueClient)(nil).GetResourcePolicies), varargs...)
}

// GetResourcePolicy mocks base method.
func (m *MockGlueClient) GetResourcePolicy(arg0 context.Context, arg1 *glue.GetResourcePolicyInput, arg2 ...func(*glue.Options)) (*glue.GetResourcePolicyOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetResourcePolicy")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetResourcePolicy", varargs...)
	ret0, _ := ret[0].(*glue.GetResourcePolicyOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetResourcePolicy indicates an expected call of GetResourcePolicy.
func (mr *MockGlueClientMockRecorder) GetResourcePolicy(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetResourcePolicy", reflect.TypeOf((*MockGlueClient)(nil).GetResourcePolicy), varargs...)
}

// GetSchema mocks base method.
func (m *MockGlueClient) GetSchema(arg0 context.Context, arg1 *glue.GetSchemaInput, arg2 ...func(*glue.Options)) (*glue.GetSchemaOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetSchema")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetSchema", varargs...)
	ret0, _ := ret[0].(*glue.GetSchemaOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetSchema indicates an expected call of GetSchema.
func (mr *MockGlueClientMockRecorder) GetSchema(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSchema", reflect.TypeOf((*MockGlueClient)(nil).GetSchema), varargs...)
}

// GetSchemaByDefinition mocks base method.
func (m *MockGlueClient) GetSchemaByDefinition(arg0 context.Context, arg1 *glue.GetSchemaByDefinitionInput, arg2 ...func(*glue.Options)) (*glue.GetSchemaByDefinitionOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetSchemaByDefinition")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetSchemaByDefinition", varargs...)
	ret0, _ := ret[0].(*glue.GetSchemaByDefinitionOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetSchemaByDefinition indicates an expected call of GetSchemaByDefinition.
func (mr *MockGlueClientMockRecorder) GetSchemaByDefinition(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSchemaByDefinition", reflect.TypeOf((*MockGlueClient)(nil).GetSchemaByDefinition), varargs...)
}

// GetSchemaVersion mocks base method.
func (m *MockGlueClient) GetSchemaVersion(arg0 context.Context, arg1 *glue.GetSchemaVersionInput, arg2 ...func(*glue.Options)) (*glue.GetSchemaVersionOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetSchemaVersion")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetSchemaVersion", varargs...)
	ret0, _ := ret[0].(*glue.GetSchemaVersionOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetSchemaVersion indicates an expected call of GetSchemaVersion.
func (mr *MockGlueClientMockRecorder) GetSchemaVersion(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSchemaVersion", reflect.TypeOf((*MockGlueClient)(nil).GetSchemaVersion), varargs...)
}

// GetSchemaVersionsDiff mocks base method.
func (m *MockGlueClient) GetSchemaVersionsDiff(arg0 context.Context, arg1 *glue.GetSchemaVersionsDiffInput, arg2 ...func(*glue.Options)) (*glue.GetSchemaVersionsDiffOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetSchemaVersionsDiff")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetSchemaVersionsDiff", varargs...)
	ret0, _ := ret[0].(*glue.GetSchemaVersionsDiffOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetSchemaVersionsDiff indicates an expected call of GetSchemaVersionsDiff.
func (mr *MockGlueClientMockRecorder) GetSchemaVersionsDiff(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSchemaVersionsDiff", reflect.TypeOf((*MockGlueClient)(nil).GetSchemaVersionsDiff), varargs...)
}

// GetSecurityConfiguration mocks base method.
func (m *MockGlueClient) GetSecurityConfiguration(arg0 context.Context, arg1 *glue.GetSecurityConfigurationInput, arg2 ...func(*glue.Options)) (*glue.GetSecurityConfigurationOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetSecurityConfiguration")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetSecurityConfiguration", varargs...)
	ret0, _ := ret[0].(*glue.GetSecurityConfigurationOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetSecurityConfiguration indicates an expected call of GetSecurityConfiguration.
func (mr *MockGlueClientMockRecorder) GetSecurityConfiguration(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSecurityConfiguration", reflect.TypeOf((*MockGlueClient)(nil).GetSecurityConfiguration), varargs...)
}

// GetSecurityConfigurations mocks base method.
func (m *MockGlueClient) GetSecurityConfigurations(arg0 context.Context, arg1 *glue.GetSecurityConfigurationsInput, arg2 ...func(*glue.Options)) (*glue.GetSecurityConfigurationsOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetSecurityConfigurations")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetSecurityConfigurations", varargs...)
	ret0, _ := ret[0].(*glue.GetSecurityConfigurationsOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetSecurityConfigurations indicates an expected call of GetSecurityConfigurations.
func (mr *MockGlueClientMockRecorder) GetSecurityConfigurations(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSecurityConfigurations", reflect.TypeOf((*MockGlueClient)(nil).GetSecurityConfigurations), varargs...)
}

// GetSession mocks base method.
func (m *MockGlueClient) GetSession(arg0 context.Context, arg1 *glue.GetSessionInput, arg2 ...func(*glue.Options)) (*glue.GetSessionOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetSession")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetSession", varargs...)
	ret0, _ := ret[0].(*glue.GetSessionOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetSession indicates an expected call of GetSession.
func (mr *MockGlueClientMockRecorder) GetSession(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSession", reflect.TypeOf((*MockGlueClient)(nil).GetSession), varargs...)
}

// GetStatement mocks base method.
func (m *MockGlueClient) GetStatement(arg0 context.Context, arg1 *glue.GetStatementInput, arg2 ...func(*glue.Options)) (*glue.GetStatementOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetStatement")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetStatement", varargs...)
	ret0, _ := ret[0].(*glue.GetStatementOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetStatement indicates an expected call of GetStatement.
func (mr *MockGlueClientMockRecorder) GetStatement(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStatement", reflect.TypeOf((*MockGlueClient)(nil).GetStatement), varargs...)
}

// GetTable mocks base method.
func (m *MockGlueClient) GetTable(arg0 context.Context, arg1 *glue.GetTableInput, arg2 ...func(*glue.Options)) (*glue.GetTableOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetTable")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetTable", varargs...)
	ret0, _ := ret[0].(*glue.GetTableOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTable indicates an expected call of GetTable.
func (mr *MockGlueClientMockRecorder) GetTable(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTable", reflect.TypeOf((*MockGlueClient)(nil).GetTable), varargs...)
}

// GetTableVersion mocks base method.
func (m *MockGlueClient) GetTableVersion(arg0 context.Context, arg1 *glue.GetTableVersionInput, arg2 ...func(*glue.Options)) (*glue.GetTableVersionOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetTableVersion")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetTableVersion", varargs...)
	ret0, _ := ret[0].(*glue.GetTableVersionOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTableVersion indicates an expected call of GetTableVersion.
func (mr *MockGlueClientMockRecorder) GetTableVersion(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTableVersion", reflect.TypeOf((*MockGlueClient)(nil).GetTableVersion), varargs...)
}

// GetTableVersions mocks base method.
func (m *MockGlueClient) GetTableVersions(arg0 context.Context, arg1 *glue.GetTableVersionsInput, arg2 ...func(*glue.Options)) (*glue.GetTableVersionsOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetTableVersions")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetTableVersions", varargs...)
	ret0, _ := ret[0].(*glue.GetTableVersionsOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTableVersions indicates an expected call of GetTableVersions.
func (mr *MockGlueClientMockRecorder) GetTableVersions(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTableVersions", reflect.TypeOf((*MockGlueClient)(nil).GetTableVersions), varargs...)
}

// GetTables mocks base method.
func (m *MockGlueClient) GetTables(arg0 context.Context, arg1 *glue.GetTablesInput, arg2 ...func(*glue.Options)) (*glue.GetTablesOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetTables")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetTables", varargs...)
	ret0, _ := ret[0].(*glue.GetTablesOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTables indicates an expected call of GetTables.
func (mr *MockGlueClientMockRecorder) GetTables(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTables", reflect.TypeOf((*MockGlueClient)(nil).GetTables), varargs...)
}

// GetTags mocks base method.
func (m *MockGlueClient) GetTags(arg0 context.Context, arg1 *glue.GetTagsInput, arg2 ...func(*glue.Options)) (*glue.GetTagsOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetTags")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetTags", varargs...)
	ret0, _ := ret[0].(*glue.GetTagsOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTags indicates an expected call of GetTags.
func (mr *MockGlueClientMockRecorder) GetTags(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTags", reflect.TypeOf((*MockGlueClient)(nil).GetTags), varargs...)
}

// GetTrigger mocks base method.
func (m *MockGlueClient) GetTrigger(arg0 context.Context, arg1 *glue.GetTriggerInput, arg2 ...func(*glue.Options)) (*glue.GetTriggerOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetTrigger")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetTrigger", varargs...)
	ret0, _ := ret[0].(*glue.GetTriggerOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTrigger indicates an expected call of GetTrigger.
func (mr *MockGlueClientMockRecorder) GetTrigger(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTrigger", reflect.TypeOf((*MockGlueClient)(nil).GetTrigger), varargs...)
}

// GetTriggers mocks base method.
func (m *MockGlueClient) GetTriggers(arg0 context.Context, arg1 *glue.GetTriggersInput, arg2 ...func(*glue.Options)) (*glue.GetTriggersOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetTriggers")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetTriggers", varargs...)
	ret0, _ := ret[0].(*glue.GetTriggersOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTriggers indicates an expected call of GetTriggers.
func (mr *MockGlueClientMockRecorder) GetTriggers(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTriggers", reflect.TypeOf((*MockGlueClient)(nil).GetTriggers), varargs...)
}

// GetUnfilteredPartitionMetadata mocks base method.
func (m *MockGlueClient) GetUnfilteredPartitionMetadata(arg0 context.Context, arg1 *glue.GetUnfilteredPartitionMetadataInput, arg2 ...func(*glue.Options)) (*glue.GetUnfilteredPartitionMetadataOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetUnfilteredPartitionMetadata")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetUnfilteredPartitionMetadata", varargs...)
	ret0, _ := ret[0].(*glue.GetUnfilteredPartitionMetadataOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUnfilteredPartitionMetadata indicates an expected call of GetUnfilteredPartitionMetadata.
func (mr *MockGlueClientMockRecorder) GetUnfilteredPartitionMetadata(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUnfilteredPartitionMetadata", reflect.TypeOf((*MockGlueClient)(nil).GetUnfilteredPartitionMetadata), varargs...)
}

// GetUnfilteredPartitionsMetadata mocks base method.
func (m *MockGlueClient) GetUnfilteredPartitionsMetadata(arg0 context.Context, arg1 *glue.GetUnfilteredPartitionsMetadataInput, arg2 ...func(*glue.Options)) (*glue.GetUnfilteredPartitionsMetadataOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetUnfilteredPartitionsMetadata")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetUnfilteredPartitionsMetadata", varargs...)
	ret0, _ := ret[0].(*glue.GetUnfilteredPartitionsMetadataOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUnfilteredPartitionsMetadata indicates an expected call of GetUnfilteredPartitionsMetadata.
func (mr *MockGlueClientMockRecorder) GetUnfilteredPartitionsMetadata(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUnfilteredPartitionsMetadata", reflect.TypeOf((*MockGlueClient)(nil).GetUnfilteredPartitionsMetadata), varargs...)
}

// GetUnfilteredTableMetadata mocks base method.
func (m *MockGlueClient) GetUnfilteredTableMetadata(arg0 context.Context, arg1 *glue.GetUnfilteredTableMetadataInput, arg2 ...func(*glue.Options)) (*glue.GetUnfilteredTableMetadataOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetUnfilteredTableMetadata")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetUnfilteredTableMetadata", varargs...)
	ret0, _ := ret[0].(*glue.GetUnfilteredTableMetadataOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUnfilteredTableMetadata indicates an expected call of GetUnfilteredTableMetadata.
func (mr *MockGlueClientMockRecorder) GetUnfilteredTableMetadata(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUnfilteredTableMetadata", reflect.TypeOf((*MockGlueClient)(nil).GetUnfilteredTableMetadata), varargs...)
}

// GetUserDefinedFunction mocks base method.
func (m *MockGlueClient) GetUserDefinedFunction(arg0 context.Context, arg1 *glue.GetUserDefinedFunctionInput, arg2 ...func(*glue.Options)) (*glue.GetUserDefinedFunctionOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetUserDefinedFunction")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetUserDefinedFunction", varargs...)
	ret0, _ := ret[0].(*glue.GetUserDefinedFunctionOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUserDefinedFunction indicates an expected call of GetUserDefinedFunction.
func (mr *MockGlueClientMockRecorder) GetUserDefinedFunction(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserDefinedFunction", reflect.TypeOf((*MockGlueClient)(nil).GetUserDefinedFunction), varargs...)
}

// GetUserDefinedFunctions mocks base method.
func (m *MockGlueClient) GetUserDefinedFunctions(arg0 context.Context, arg1 *glue.GetUserDefinedFunctionsInput, arg2 ...func(*glue.Options)) (*glue.GetUserDefinedFunctionsOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetUserDefinedFunctions")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetUserDefinedFunctions", varargs...)
	ret0, _ := ret[0].(*glue.GetUserDefinedFunctionsOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUserDefinedFunctions indicates an expected call of GetUserDefinedFunctions.
func (mr *MockGlueClientMockRecorder) GetUserDefinedFunctions(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserDefinedFunctions", reflect.TypeOf((*MockGlueClient)(nil).GetUserDefinedFunctions), varargs...)
}

// GetWorkflow mocks base method.
func (m *MockGlueClient) GetWorkflow(arg0 context.Context, arg1 *glue.GetWorkflowInput, arg2 ...func(*glue.Options)) (*glue.GetWorkflowOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetWorkflow")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetWorkflow", varargs...)
	ret0, _ := ret[0].(*glue.GetWorkflowOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetWorkflow indicates an expected call of GetWorkflow.
func (mr *MockGlueClientMockRecorder) GetWorkflow(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWorkflow", reflect.TypeOf((*MockGlueClient)(nil).GetWorkflow), varargs...)
}

// GetWorkflowRun mocks base method.
func (m *MockGlueClient) GetWorkflowRun(arg0 context.Context, arg1 *glue.GetWorkflowRunInput, arg2 ...func(*glue.Options)) (*glue.GetWorkflowRunOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetWorkflowRun")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetWorkflowRun", varargs...)
	ret0, _ := ret[0].(*glue.GetWorkflowRunOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetWorkflowRun indicates an expected call of GetWorkflowRun.
func (mr *MockGlueClientMockRecorder) GetWorkflowRun(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWorkflowRun", reflect.TypeOf((*MockGlueClient)(nil).GetWorkflowRun), varargs...)
}

// GetWorkflowRunProperties mocks base method.
func (m *MockGlueClient) GetWorkflowRunProperties(arg0 context.Context, arg1 *glue.GetWorkflowRunPropertiesInput, arg2 ...func(*glue.Options)) (*glue.GetWorkflowRunPropertiesOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetWorkflowRunProperties")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetWorkflowRunProperties", varargs...)
	ret0, _ := ret[0].(*glue.GetWorkflowRunPropertiesOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetWorkflowRunProperties indicates an expected call of GetWorkflowRunProperties.
func (mr *MockGlueClientMockRecorder) GetWorkflowRunProperties(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWorkflowRunProperties", reflect.TypeOf((*MockGlueClient)(nil).GetWorkflowRunProperties), varargs...)
}

// GetWorkflowRuns mocks base method.
func (m *MockGlueClient) GetWorkflowRuns(arg0 context.Context, arg1 *glue.GetWorkflowRunsInput, arg2 ...func(*glue.Options)) (*glue.GetWorkflowRunsOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to GetWorkflowRuns")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetWorkflowRuns", varargs...)
	ret0, _ := ret[0].(*glue.GetWorkflowRunsOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetWorkflowRuns indicates an expected call of GetWorkflowRuns.
func (mr *MockGlueClientMockRecorder) GetWorkflowRuns(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWorkflowRuns", reflect.TypeOf((*MockGlueClient)(nil).GetWorkflowRuns), varargs...)
}

// ListBlueprints mocks base method.
func (m *MockGlueClient) ListBlueprints(arg0 context.Context, arg1 *glue.ListBlueprintsInput, arg2 ...func(*glue.Options)) (*glue.ListBlueprintsOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to ListBlueprints")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListBlueprints", varargs...)
	ret0, _ := ret[0].(*glue.ListBlueprintsOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListBlueprints indicates an expected call of ListBlueprints.
func (mr *MockGlueClientMockRecorder) ListBlueprints(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListBlueprints", reflect.TypeOf((*MockGlueClient)(nil).ListBlueprints), varargs...)
}

// ListCrawlers mocks base method.
func (m *MockGlueClient) ListCrawlers(arg0 context.Context, arg1 *glue.ListCrawlersInput, arg2 ...func(*glue.Options)) (*glue.ListCrawlersOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to ListCrawlers")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListCrawlers", varargs...)
	ret0, _ := ret[0].(*glue.ListCrawlersOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListCrawlers indicates an expected call of ListCrawlers.
func (mr *MockGlueClientMockRecorder) ListCrawlers(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListCrawlers", reflect.TypeOf((*MockGlueClient)(nil).ListCrawlers), varargs...)
}

// ListCrawls mocks base method.
func (m *MockGlueClient) ListCrawls(arg0 context.Context, arg1 *glue.ListCrawlsInput, arg2 ...func(*glue.Options)) (*glue.ListCrawlsOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to ListCrawls")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListCrawls", varargs...)
	ret0, _ := ret[0].(*glue.ListCrawlsOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListCrawls indicates an expected call of ListCrawls.
func (mr *MockGlueClientMockRecorder) ListCrawls(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListCrawls", reflect.TypeOf((*MockGlueClient)(nil).ListCrawls), varargs...)
}

// ListCustomEntityTypes mocks base method.
func (m *MockGlueClient) ListCustomEntityTypes(arg0 context.Context, arg1 *glue.ListCustomEntityTypesInput, arg2 ...func(*glue.Options)) (*glue.ListCustomEntityTypesOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to ListCustomEntityTypes")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListCustomEntityTypes", varargs...)
	ret0, _ := ret[0].(*glue.ListCustomEntityTypesOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListCustomEntityTypes indicates an expected call of ListCustomEntityTypes.
func (mr *MockGlueClientMockRecorder) ListCustomEntityTypes(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListCustomEntityTypes", reflect.TypeOf((*MockGlueClient)(nil).ListCustomEntityTypes), varargs...)
}

// ListDataQualityResults mocks base method.
func (m *MockGlueClient) ListDataQualityResults(arg0 context.Context, arg1 *glue.ListDataQualityResultsInput, arg2 ...func(*glue.Options)) (*glue.ListDataQualityResultsOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to ListDataQualityResults")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListDataQualityResults", varargs...)
	ret0, _ := ret[0].(*glue.ListDataQualityResultsOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListDataQualityResults indicates an expected call of ListDataQualityResults.
func (mr *MockGlueClientMockRecorder) ListDataQualityResults(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListDataQualityResults", reflect.TypeOf((*MockGlueClient)(nil).ListDataQualityResults), varargs...)
}

// ListDataQualityRuleRecommendationRuns mocks base method.
func (m *MockGlueClient) ListDataQualityRuleRecommendationRuns(arg0 context.Context, arg1 *glue.ListDataQualityRuleRecommendationRunsInput, arg2 ...func(*glue.Options)) (*glue.ListDataQualityRuleRecommendationRunsOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to ListDataQualityRuleRecommendationRuns")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListDataQualityRuleRecommendationRuns", varargs...)
	ret0, _ := ret[0].(*glue.ListDataQualityRuleRecommendationRunsOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListDataQualityRuleRecommendationRuns indicates an expected call of ListDataQualityRuleRecommendationRuns.
func (mr *MockGlueClientMockRecorder) ListDataQualityRuleRecommendationRuns(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListDataQualityRuleRecommendationRuns", reflect.TypeOf((*MockGlueClient)(nil).ListDataQualityRuleRecommendationRuns), varargs...)
}

// ListDataQualityRulesetEvaluationRuns mocks base method.
func (m *MockGlueClient) ListDataQualityRulesetEvaluationRuns(arg0 context.Context, arg1 *glue.ListDataQualityRulesetEvaluationRunsInput, arg2 ...func(*glue.Options)) (*glue.ListDataQualityRulesetEvaluationRunsOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to ListDataQualityRulesetEvaluationRuns")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListDataQualityRulesetEvaluationRuns", varargs...)
	ret0, _ := ret[0].(*glue.ListDataQualityRulesetEvaluationRunsOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListDataQualityRulesetEvaluationRuns indicates an expected call of ListDataQualityRulesetEvaluationRuns.
func (mr *MockGlueClientMockRecorder) ListDataQualityRulesetEvaluationRuns(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListDataQualityRulesetEvaluationRuns", reflect.TypeOf((*MockGlueClient)(nil).ListDataQualityRulesetEvaluationRuns), varargs...)
}

// ListDataQualityRulesets mocks base method.
func (m *MockGlueClient) ListDataQualityRulesets(arg0 context.Context, arg1 *glue.ListDataQualityRulesetsInput, arg2 ...func(*glue.Options)) (*glue.ListDataQualityRulesetsOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to ListDataQualityRulesets")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListDataQualityRulesets", varargs...)
	ret0, _ := ret[0].(*glue.ListDataQualityRulesetsOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListDataQualityRulesets indicates an expected call of ListDataQualityRulesets.
func (mr *MockGlueClientMockRecorder) ListDataQualityRulesets(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListDataQualityRulesets", reflect.TypeOf((*MockGlueClient)(nil).ListDataQualityRulesets), varargs...)
}

// ListDevEndpoints mocks base method.
func (m *MockGlueClient) ListDevEndpoints(arg0 context.Context, arg1 *glue.ListDevEndpointsInput, arg2 ...func(*glue.Options)) (*glue.ListDevEndpointsOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to ListDevEndpoints")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListDevEndpoints", varargs...)
	ret0, _ := ret[0].(*glue.ListDevEndpointsOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListDevEndpoints indicates an expected call of ListDevEndpoints.
func (mr *MockGlueClientMockRecorder) ListDevEndpoints(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListDevEndpoints", reflect.TypeOf((*MockGlueClient)(nil).ListDevEndpoints), varargs...)
}

// ListJobs mocks base method.
func (m *MockGlueClient) ListJobs(arg0 context.Context, arg1 *glue.ListJobsInput, arg2 ...func(*glue.Options)) (*glue.ListJobsOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to ListJobs")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListJobs", varargs...)
	ret0, _ := ret[0].(*glue.ListJobsOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListJobs indicates an expected call of ListJobs.
func (mr *MockGlueClientMockRecorder) ListJobs(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListJobs", reflect.TypeOf((*MockGlueClient)(nil).ListJobs), varargs...)
}

// ListMLTransforms mocks base method.
func (m *MockGlueClient) ListMLTransforms(arg0 context.Context, arg1 *glue.ListMLTransformsInput, arg2 ...func(*glue.Options)) (*glue.ListMLTransformsOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to ListMLTransforms")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListMLTransforms", varargs...)
	ret0, _ := ret[0].(*glue.ListMLTransformsOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListMLTransforms indicates an expected call of ListMLTransforms.
func (mr *MockGlueClientMockRecorder) ListMLTransforms(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListMLTransforms", reflect.TypeOf((*MockGlueClient)(nil).ListMLTransforms), varargs...)
}

// ListRegistries mocks base method.
func (m *MockGlueClient) ListRegistries(arg0 context.Context, arg1 *glue.ListRegistriesInput, arg2 ...func(*glue.Options)) (*glue.ListRegistriesOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to ListRegistries")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListRegistries", varargs...)
	ret0, _ := ret[0].(*glue.ListRegistriesOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListRegistries indicates an expected call of ListRegistries.
func (mr *MockGlueClientMockRecorder) ListRegistries(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListRegistries", reflect.TypeOf((*MockGlueClient)(nil).ListRegistries), varargs...)
}

// ListSchemaVersions mocks base method.
func (m *MockGlueClient) ListSchemaVersions(arg0 context.Context, arg1 *glue.ListSchemaVersionsInput, arg2 ...func(*glue.Options)) (*glue.ListSchemaVersionsOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to ListSchemaVersions")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListSchemaVersions", varargs...)
	ret0, _ := ret[0].(*glue.ListSchemaVersionsOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListSchemaVersions indicates an expected call of ListSchemaVersions.
func (mr *MockGlueClientMockRecorder) ListSchemaVersions(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListSchemaVersions", reflect.TypeOf((*MockGlueClient)(nil).ListSchemaVersions), varargs...)
}

// ListSchemas mocks base method.
func (m *MockGlueClient) ListSchemas(arg0 context.Context, arg1 *glue.ListSchemasInput, arg2 ...func(*glue.Options)) (*glue.ListSchemasOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to ListSchemas")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListSchemas", varargs...)
	ret0, _ := ret[0].(*glue.ListSchemasOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListSchemas indicates an expected call of ListSchemas.
func (mr *MockGlueClientMockRecorder) ListSchemas(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListSchemas", reflect.TypeOf((*MockGlueClient)(nil).ListSchemas), varargs...)
}

// ListSessions mocks base method.
func (m *MockGlueClient) ListSessions(arg0 context.Context, arg1 *glue.ListSessionsInput, arg2 ...func(*glue.Options)) (*glue.ListSessionsOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to ListSessions")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListSessions", varargs...)
	ret0, _ := ret[0].(*glue.ListSessionsOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListSessions indicates an expected call of ListSessions.
func (mr *MockGlueClientMockRecorder) ListSessions(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListSessions", reflect.TypeOf((*MockGlueClient)(nil).ListSessions), varargs...)
}

// ListStatements mocks base method.
func (m *MockGlueClient) ListStatements(arg0 context.Context, arg1 *glue.ListStatementsInput, arg2 ...func(*glue.Options)) (*glue.ListStatementsOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to ListStatements")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListStatements", varargs...)
	ret0, _ := ret[0].(*glue.ListStatementsOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListStatements indicates an expected call of ListStatements.
func (mr *MockGlueClientMockRecorder) ListStatements(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListStatements", reflect.TypeOf((*MockGlueClient)(nil).ListStatements), varargs...)
}

// ListTriggers mocks base method.
func (m *MockGlueClient) ListTriggers(arg0 context.Context, arg1 *glue.ListTriggersInput, arg2 ...func(*glue.Options)) (*glue.ListTriggersOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to ListTriggers")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListTriggers", varargs...)
	ret0, _ := ret[0].(*glue.ListTriggersOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListTriggers indicates an expected call of ListTriggers.
func (mr *MockGlueClientMockRecorder) ListTriggers(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListTriggers", reflect.TypeOf((*MockGlueClient)(nil).ListTriggers), varargs...)
}

// ListWorkflows mocks base method.
func (m *MockGlueClient) ListWorkflows(arg0 context.Context, arg1 *glue.ListWorkflowsInput, arg2 ...func(*glue.Options)) (*glue.ListWorkflowsOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to ListWorkflows")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListWorkflows", varargs...)
	ret0, _ := ret[0].(*glue.ListWorkflowsOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListWorkflows indicates an expected call of ListWorkflows.
func (mr *MockGlueClientMockRecorder) ListWorkflows(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListWorkflows", reflect.TypeOf((*MockGlueClient)(nil).ListWorkflows), varargs...)
}

// QuerySchemaVersionMetadata mocks base method.
func (m *MockGlueClient) QuerySchemaVersionMetadata(arg0 context.Context, arg1 *glue.QuerySchemaVersionMetadataInput, arg2 ...func(*glue.Options)) (*glue.QuerySchemaVersionMetadataOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to QuerySchemaVersionMetadata")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QuerySchemaVersionMetadata", varargs...)
	ret0, _ := ret[0].(*glue.QuerySchemaVersionMetadataOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// QuerySchemaVersionMetadata indicates an expected call of QuerySchemaVersionMetadata.
func (mr *MockGlueClientMockRecorder) QuerySchemaVersionMetadata(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QuerySchemaVersionMetadata", reflect.TypeOf((*MockGlueClient)(nil).QuerySchemaVersionMetadata), varargs...)
}

// SearchTables mocks base method.
func (m *MockGlueClient) SearchTables(arg0 context.Context, arg1 *glue.SearchTablesInput, arg2 ...func(*glue.Options)) (*glue.SearchTablesOutput, error) {

	// Assertion inserted by client/mockgen/main.go
	o := &glue.Options{}
	for _, f := range arg2 {
		f(o)
	}
	if o.Region == "" {
		m.ctrl.T.Errorf("Region not set in call to SearchTables")
	}

	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SearchTables", varargs...)
	ret0, _ := ret[0].(*glue.SearchTablesOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SearchTables indicates an expected call of SearchTables.
func (mr *MockGlueClientMockRecorder) SearchTables(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SearchTables", reflect.TypeOf((*MockGlueClient)(nil).SearchTables), varargs...)
}
