package timescale

import (
	"context"
	"fmt"
	"strings"

	"github.com/cloudquery/cloudquery/pkg/client/history"
	"github.com/cloudquery/cq-provider-sdk/provider/schema"
	"github.com/georgysavva/scany/pgxscan"
	"github.com/hashicorp/go-hclog"
	"github.com/jackc/pgx/v4"
	"github.com/jackc/pgx/v4/pgxpool"
)

/*
setup -> (creates history schema, history functions)
create (migrate) -> creates all tables in history schema (we set schema like we do now)
finalizes -> fix constraints / pks and run create_hypertable + retention policy and all tables

+ recreate views in public schema

need to fix PKs and constraints (remove FKs, add cq_fetch_date to UNIQUE) BEFORE we can do create_hypertable
*/

type DDLManager struct {
	log     hclog.Logger
	cfg     *history.Config
	dialect schema.Dialect
}

func NewDDLManager(cfg *history.Config, l hclog.Logger, dt schema.DialectType) (*DDLManager, error) {
	if dt != schema.TSDB {
		return nil, fmt.Errorf("history is only supported on timescaledb")
	}

	return &DDLManager{
		log:     l,
		cfg:     cfg,
		dialect: schema.GetDialect(dt),
	}, nil
}

func (h DDLManager) CreateTable(ctx context.Context, conn *pgxpool.Conn, t, p *schema.Table) error {
	if err := h.createHyperTable(ctx, t, p, conn); err != nil {
		return fmt.Errorf("failed to create hypertable for table: %s: %w", t.Name, err)
	}

	if err := conn.BeginTxFunc(ctx, pgx.TxOptions{}, func(tx pgx.Tx) error {
		// Must drop the view first -- CREATE OR REPLACE view won't cut it if columns are changed. PostgreSQL doc states:
		// > The new query must generate the same columns that were generated by the existing view query (that is, the same column names in the same order and with
		// > the same data types), but it may add additional columns to the end of the list.
		// ref: https://www.postgresql.org/docs/14/sql-createview.html

		if _, err := tx.Exec(ctx, fmt.Sprintf(dropTableView, t.Name)); err != nil {
			return fmt.Errorf("failed to drop view for table: %w", err)
		}

		if _, err := tx.Exec(ctx, fmt.Sprintf(createTableView, t.Name)); err != nil {
			return fmt.Errorf("failed to create view for table: %w", err)
		}

		return nil
	}); err != nil {
		return fmt.Errorf("tx failed for %s: %w", t.Name, err)
	}

	if p != nil {
		if err := h.buildCascadeTrigger(ctx, conn, t, p); err != nil {
			return fmt.Errorf("table build %s failed: %w", t.Name, err)
		}
	}

	// Create relation tables
	for _, r := range t.Relations {
		h.log.Debug("creating table relation", "table", r.Name)
		if err := h.CreateTable(ctx, conn, r, t); err != nil {
			return err
		}
	}

	return nil
}

func (h DDLManager) createHyperTable(ctx context.Context, t, p *schema.Table, conn *pgxpool.Conn) error {
	var hyperTable createHyperTableResult
	tName := fmt.Sprintf(`"history"."%s"`, t.Name)
	if err := pgxscan.Get(ctx, conn, &hyperTable, fmt.Sprintf(createHyperTable, h.cfg.TimeInterval), tName); err != nil {
		return fmt.Errorf("failed to create hypertable: %w", err)
	}
	h.log.Debug("created hyper table for table", "table", hyperTable.TableName, "id", hyperTable.HypertableId, "created", hyperTable.Created)
	if p != nil {
		return nil
	}
	if _, err := conn.Exec(ctx, fmt.Sprintf(dataRetentionPolicy, h.cfg.Retention), tName); err != nil {
		return err
	}
	h.log.Debug("created data retention policy", "table", hyperTable.TableName, "days", h.cfg.Retention)
	return nil
}

func (h DDLManager) buildCascadeTrigger(ctx context.Context, conn *pgxpool.Conn, t, p *schema.Table) error {
	c := h.findParentIdColumn(t)
	if c == nil {
		return fmt.Errorf("failed to find parent cq id column for %s", t.Name)
	}
	if _, err := conn.Exec(ctx, "SELECT history.build_trigger($1, $2, $3);", p.Name, t.Name, c.Name); err != nil {
		return fmt.Errorf("failed to create trigger: %w", err)
	}
	if _, err := conn.Exec(ctx, fmt.Sprintf("CREATE INDEX ON \"history\".\"%s\" (cq_fetch_date, %s)", t.Name, c.Name)); err != nil {
		return fmt.Errorf("failed to create index on %s (cq_fetch_date, %s): %w", t.Name, c.Name, err)
	}
	return nil
}

func (h DDLManager) findParentIdColumn(t *schema.Table) *schema.Column {
	for _, c := range t.Columns {
		if c.Meta().Resolver != nil && c.Meta().Resolver.Name == "ParentIdResolver" {
			return &c
		}
	}
	// Support old school columns instead of meta, this is backwards compatibility for providers using SDK prior v0.5.0
	for _, c := range t.Columns {
		if strings.HasSuffix(c.Name, "cq_id") && c.Name != "cq_id" {
			return &c
		}
	}

	return nil
}
