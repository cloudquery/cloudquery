package cmd

import (
	"bytes"
	"fmt"
	"os/exec"
	"path"
	"strings"

	"github.com/cloudquery/cloudquery/cli/internal/plugin/managedsource"
	"github.com/cloudquery/plugin-pb-go/pb/source/v1"
	"github.com/cloudquery/plugin-pb-go/specs"
	"github.com/rs/zerolog/log"
	"github.com/spf13/cobra"
)

const (
	tablesShort   = "Generate documentation for all supported tables of source plugins specified in the spec(s)"
	tablesExample = `# Generate documentation for all supported tables of source plugins specified in the spec(s) 
cloudquery tables ./directory
# The default format is JSON, you can override it with --format
cloudquery tables ./directory --format markdown
# You can also specify an output directory. The default is ./cq-docs
cloudquery tables ./directory --output-dir ./docs
`
)

func NewCmdTables() *cobra.Command {
	cmd := &cobra.Command{
		Use:     "tables [files or directories]",
		Short:   tablesShort,
		Long:    tablesShort,
		Example: tablesExample,
		Args:    cobra.MinimumNArgs(1),
		RunE:    tables,
	}
	cmd.Flags().String("output-dir", "cq-docs", "Base output directory for generated files")
	cmd.Flags().String("format", "json", "Output format. One of: json, markdown")
	return cmd
}

func tables(cmd *cobra.Command, args []string) error {
	cqDir, err := cmd.Flags().GetString("cq-dir")
	if err != nil {
		return err
	}

	format, err := cmd.Flags().GetString("format")
	if err != nil {
		return err
	}
	outputDir, err := cmd.Flags().GetString("output-dir")
	if err != nil {
		return err
	}
	ctx := cmd.Context()
	log.Info().Strs("args", args).Msg("Loading spec(s)")
	fmt.Printf("Loading spec(s) from %s\n", strings.Join(args, ", "))
	specReader, err := specs.NewSpecReader(args)
	if err != nil {
		return fmt.Errorf("failed to load spec(s) from %s. Error: %w", strings.Join(args, ", "), err)
	}
	opts := []managedsource.Option{
		managedsource.WithLogger(log.Logger),
		managedsource.WithDirectory(cqDir),
	}
	sourceClients, err := managedsource.NewClients(ctx, specReader.Sources, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err := sourceClients.Terminate(); err != nil {
			fmt.Println(err)
		}
	}()
	for _, sourceClient := range sourceClients {
		outputPath := path.Join(outputDir, sourceClient.Spec.Name)
		pbSourceClient := source.NewSourceClient(sourceClient.Conn)
		if _, err := pbSourceClient.GenDocs(ctx, &source.GenDocs_Request{
			Format: source.GenDocs_FORMAT(source.GenDocs_FORMAT_value[format]),
			Path:   outputPath,
		}); err == nil {
			continue
		}
		// If we have a local path, we can fallback to running the docs command
		if err != nil && sourceClient.LocalPath == "" {
			return fmt.Errorf("failed to call GenDocs: %w", err)
		}
		args := []string{"doc", "--format", format, outputPath}
		cmd := exec.CommandContext(ctx, sourceClient.LocalPath, args...)
		var outb, errb bytes.Buffer
		cmd.Stdout = &outb
		cmd.Stderr = &errb
		if err := cmd.Run(); err != nil {
			return fmt.Errorf("failed to run source plugin %s: %w. Output: %s. Error: %s", sourceClient.LocalPath, err, outb.String(), errb.String())
		}
	}

	return nil
}
